import os
import pytest
from unittest.mock import patch
from kafka_writer import KafkaWriter  # Adjust import based on your module structure

@pytest.fixture
def mock_ssl_files(tmp_path):
    """Create fake SSL certificate files to prevent Kafka SSL errors."""
    ca_cert = tmp_path / "ca.pem"
    key_cert = tmp_path / "topic.key"
    
    ca_cert.write_text("FAKE CA CERT DATA")
    key_cert.write_text("FAKE KEY CERT DATA")

    return str(ca_cert), str(key_cert)

@pytest.fixture
def mock_kafka_config(mock_ssl_files):
    """Mock Kafka configuration to use fake SSL paths."""
    ca_path, key_path = mock_ssl_files

    return {
        "security.protocol": "SSL",
        "ssl.ca.location": ca_path,
        "ssl.key.location": key_path,
        "bootstrap.servers": "mock-server:9092",
        "client.id": "mock-client"
    }

@patch("kafka_writer.KafkaWriter")
def test_kafka_writer_init(mock_kafka_writer, mock_kafka_config):
    """Test KafkaWriter initialization with mocked SSL certs."""
    
    # Force the mock KafkaWriter to return the fake SSL config
    mock_kafka_writer.return_value._kafka_conf = mock_kafka_config
    
    # Initialize KafkaWriter (it will use the mocked paths)
    writer = KafkaWriter(config_env="mock_env")

    # Validate that the producer received the correct config
    assert writer._kafka_conf["ssl.ca.location"] == mock_kafka_config["ssl.ca.location"]
    assert writer._kafka_conf["ssl.key.location"] == mock_kafka_config["ssl.key.location"]

    print("Mocked Kafka Config:", writer._kafka_conf)  # Debugging output