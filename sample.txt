import pytest
from unittest.mock import patch, MagicMock, call
import sys
from pathlib import Path
import io

# This will be needed to import the main module
sys.path.append(str(Path(__file__).parent.parent))

# Import the module to test
from Kafka_sync import kafka_sync
from Kafka_sync.kafka_sync import Kafka_sync

@pytest.fixture
def mock_argparse():
    """Mock the ArgumentParser to test argument handling."""
    with patch('argparse.ArgumentParser', autospec=True) as mock_parser_cls:
        mock_parser = mock_parser_cls.return_value
        mock_args = MagicMock()
        mock_parser.parse_args.return_value = mock_args
        mock_args.toml_file = "test_config.toml"
        yield mock_parser, mock_args

@pytest.fixture
def mock_kafka_sync():
    """Mock the Kafka_sync class."""
    with patch('Kafka_sync.kafka_sync.Kafka_sync', autospec=True) as mock_ks_cls:
        mock_ks = mock_ks_cls.return_value
        yield mock_ks

@pytest.fixture
def mock_path():
    """Mock Path for absolute path testing."""
    with patch('pathlib.Path', autospec=True) as mock_path_cls:
        mock_path_instance = mock_path_cls.return_value
        mock_path_instance.absolute.return_value = "/absolute/path/to/config.toml"
        yield mock_path_cls

@pytest.fixture
def mock_print():
    """Mock print function to capture output."""
    with patch('builtins.print') as mock_print_func:
        yield mock_print_func

def run_main_module():
    """Helper to run the __main__ module."""
    # Reset modules to ensure fresh imports
    if 'Kafka_sync.__main__' in sys.modules:
        del sys.modules['Kafka_sync.__main__']
    
    # Import and run the main module
    import Kafka_sync.__main__

# Test for successful execution path
def test_main_successful_execution(mock_argparse, mock_kafka_sync, mock_path, mock_print):
    """Test the main function's successful execution path."""
    # Setup mocks
    parser, args = mock_argparse
    
    # Run the main function
    with patch.object(sys, 'argv', ['kafka_sync', '-f', 'test_config.toml']):
        run_main_module()
    
    # Verify argument parsing
    parser.add_argument.assert_any_call('-f', '--file', dest='toml_file', help=pytest.approx('path to toml config file'))
    
    # Verify Kafka_sync instantiation and execution
    mock_kafka_sync.start.assert_called_once()
    mock_print.assert_any_call(f"Starting sync using {'/absolute/path/to/config.toml'}")

# Test keyboard interrupt handling
def test_main_keyboard_interrupt(mock_argparse, mock_kafka_sync, mock_print):
    """Test handling of KeyboardInterrupt."""
    # Setup mock to raise KeyboardInterrupt
    mock_kafka_sync.start.side_effect = KeyboardInterrupt()
    
    # Run the main function
    with patch.object(sys, 'argv', ['kafka_sync', '-f', 'test_config.toml']):
        run_main_module()
    
    # Verify stop was called and message printed
    mock_kafka_sync.stop.assert_called_once()
    mock_print.assert_any_call("Caught Keyboard Interrupt")

# Test exception handling
def test_main_general_exception(mock_argparse, mock_kafka_sync, mock_print):
    """Test handling of general exceptions."""
    # Setup mock to raise Exception
    test_exception = Exception("Test error")
    mock_kafka_sync.start.side_effect = test_exception
    
    # Run the main function
    with patch.object(sys, 'argv', ['kafka_sync', '-f', 'test_config.toml']):
        run_main_module()
    
    # Verify exception handling
    mock_kafka_sync.stop.assert_called_once()
    mock_print.assert_any_call(f"Exception Caught stopping Kafka Client:\n {test_exception}")

# Test finally block execution
def test_main_finally_block(mock_argparse, mock_kafka_sync):
    """Test that the finally block always executes."""
    # Setup mock to raise Exception and then another exception in stop
    mock_kafka_sync.start.side_effect = Exception("Start error")
    mock_kafka_sync.stop.side_effect = Exception("Stop error")
    
    # Run the main function
    with patch.object(sys, 'argv', ['kafka_sync', '-f', 'test_config.toml']):
        # We expect this to not raise an exception due to the finally block
        run_main_module()
    
    # Verify stop was called even though it raised an exception
    mock_kafka_sync.stop.assert_called_once()

# Test the __name__ == "__main__" block
def test_main_module_execution(mock_argparse, mock_kafka_sync):
    """Test execution when module is run directly."""
    # Mock __name__ to be "__main__"
    with patch.dict('sys.modules', {'__main__': sys.modules[__name__]}):
        with patch('Kafka_sync.__main__.__name__', '__main__'):
            # Create a mock for the main function
            with patch('Kafka_sync.__main__.main') as mock_main:
                # Import the module again
                if 'Kafka_sync.__main__' in sys.modules:
                    del sys.modules['Kafka_sync.__main__']
                import Kafka_sync.__main__
                
                # Verify main was called
                mock_main.assert_called_once()

# Test the script with actual argument parsing
def test_main_with_actual_args():
    """Test with actual argument parsing (less mocking)."""
    with patch('Kafka_sync.kafka_sync.Kafka_sync', autospec=True) as mock_ks_cls:
        mock_ks = mock_ks_cls.return_value
        
        # Run with actual argument parsing
        with patch.object(sys, 'argv', ['kafka_sync', '-f', 'test_config.toml']):
            # Capture stdout to verify output
            captured_stdout = io.StringIO()
            with patch('sys.stdout', captured_stdout):
                run_main_module()
        
        # Verify Kafka_sync was initialized with right file
        mock_ks_cls.assert_called_once()
        assert mock_ks_cls.call_args[0][0].endswith('test_config.toml')
        
        # Verify start was called
        mock_ks.start.assert_called_once()

# Test without mocking Path to verify actual path handling
def test_main_real_path_handling():
    """Test with real Path handling."""
    with patch('Kafka_sync.kafka_sync.Kafka_sync', autospec=True) as mock_ks_cls:
        mock_ks = mock_ks_cls.return_value
        
        # Create a test file
        test_file = Path("temp_test_config.toml")
        test_file.touch()
        
        try:
            # Run with actual file
            with patch.object(sys, 'argv', ['kafka_sync', '-f', str(test_file)]):
                with patch('builtins.print') as mock_print:
                    run_main_module()
            
            # Verify absolute path was used
            abs_path = test_file.absolute()
            mock_print.assert_any_call(f"Starting sync using {abs_path}")
            
        finally:
            # Clean up
            if test_file.exists():
                test_file.unlink()

# Test the run loop
def test_main_run_loop(mock_argparse, mock_kafka_sync, mock_print):
    """Test the run loop with sleep."""
    # Setup to run loop once then break
    def side_effect():
        # Set run to False after first iteration
        mock_kafka_sync.run = False
    
    mock_kafka_sync.run = True
    mock_kafka_sync.start.side_effect = side_effect
    
    # Run the main function
    with patch('time.sleep') as mock_sleep:
        with patch.object(sys, 'argv', ['kafka_sync', '-f', 'test_config.toml']):
            run_main_module()
    
    # Verify sleep was called with argument 4
    mock_sleep.assert_called_with(4)