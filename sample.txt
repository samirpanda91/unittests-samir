import pytest
import toml
from unittest.mock import patch, MagicMock
from pathlib import Path
from your_module import Kafka_sync, Aiops_config  # Replace 'your_module' with the actual module name

@pytest.fixture
def mock_aiops_config():
    """Mock Aiops_config.get_instance to return the parsed TOML config from the existing test file."""
    config_file = Path("tests/test_config.toml")  # Use the existing test file
    parsed_config = toml.load(config_file)  # Load the config file

    # ✅ Ensure 'filters' is placed at the top level inside 'sync_config'
    return {
        "src": parsed_config["config_items"]["src"],
        "dest": parsed_config["config_items"]["dest"],
        "filters": parsed_config["config_items"]["src"].get("filters", {}),  # ✅ Move filters up
    }

@patch("your_module.Aiops_config.get_instance")
@patch("your_module.Kafka_Client")  # Mock Kafka Client
def test_kafka_sync(mock_kafka_client, mock_get_instance, mock_aiops_config):
    """Test Kafka_sync initialization using the existing TOML config."""
    
    # Mock Aiops_config.get_instance to return mock config
    mock_get_instance.return_value = mock_aiops_config

    # Mock Kafka Client to prevent real Kafka calls
    mock_kafka_client.return_value = MagicMock()

    # Initialize Kafka_sync
    kafka_sync = Kafka_sync("tests/test_config.toml")

    # Assertions to validate configuration is correctly loaded
    assert kafka_sync.sync_config["filters"] == mock_aiops_config["filters"]  # ✅ Now filters are at sync_config level